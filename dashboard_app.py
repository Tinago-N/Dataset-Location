# -*- coding: utf-8 -*-
"""CHAT DASH v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hHYNoDoi_0WlW_a0PcQgvBcG_8C1S00Z
"""

import pandas as pd
import plotly.express as px
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc
import dash_table
import plotly.graph_objs as go
from plotly.subplots import make_subplots

url = 'https://raw.githubusercontent.com/Tinago-N/Dataset-Location/main/Train.csv'
data = pd.read_csv(url)

# Load the customer segmentation data
data.head()

# Create the Sunburst Chart
sunburst1 = px.sunburst(data,
                  path=['Cluster', 'Gender', 'Spending_Score', 'Ever_Married'],
                  title = "Sunburst Chart for Cluster, Gender,\n Spending Score, and Ever Married",
                  color='Cluster',
                  color_continuous_scale='twilight',  # Change this to a different color scale
                  branchvalues='total',
                  template='plotly_dark')
sunburst1.show()

# Create the Sunburst Chart
sunburst2 = px.sunburst(data,
                  path=['Profession', 'Graduated'],
                  title='Sunburst Chart for Profession & Graduated',
                  color='Cluster',
                  color_continuous_scale='YlOrBr',  # Change this to a different color scale
                  branchvalues='total',
                  template='plotly_dark')
sunburst2.show()

# Define the Sidebar and Content styles
SIDEBAR_STYLE = {
    'position': 'fixed',
    'top': 0,
    'left': 0,
    'bottom': 0,
    'width': '12rem',
    'padding': '2rem 1rem',
    'background-color': 'rgba(120, 120, 120, 0.4)',
}

CONTENT_STYLE = {
    'margin-left': '15rem',
    'margin-right': '2rem',
    'padding': '2rem 1rem',
}

# Create a dictionary for the dropdown options based on the data
dropdown_options = [{'label': str(id), 'value': id} for id in data['ID']]

# Create the sidebar
sidebar = html.Div(
    [
        html.Hr(),
        html.P('Customer Segmentation Dashboard', className='text-center p-3 border border-dark'),
        html.Hr(),
        dbc.Nav(
            [
                dbc.NavLink("Customer Base", href="/", className="nav-link"),
                dbc.NavLink('Churn Reduction', href="/churn", active='exact'),
                dbc.NavLink('Sunburst Chart', href="/sunburst", active='exact'),
                dbc.NavLink('Data Study', href="/tableview", active='exact'),
                dbc.NavLink('About Us', href="/about-us", active='exact'),
            ],
            vertical=True,
            pills=True,
        ),
        html.Div(
            [
                html.Br(),
                html.Br(),
                html.Br(),
                html.P('Created by NRB', style={'text-align': 'center', 'margin': '0'}),
                html.P('NOT Ngoni Rejoice Brandon but', style={'text-align': 'center', 'margin': '0'}),
                html.P('National Resources & Business', style={'text-align': 'center', 'margin': '0'}),
            ],
            style={'padding': '10px 0', 'text-align': 'center'}
        ),
    ],
    style=SIDEBAR_STYLE,
)

# Create the content area
content = html.Div(id='page-content', children=[], style=CONTENT_STYLE)

"""## CHARTS"""

train_df = data

# Count the occurrences of each gender category
gender_counts = train_df['Gender'].value_counts().reset_index()

# Create an interactive pie chart using Plotly
fig_gender = px.pie(gender_counts, names='index', values='Gender', hole=0.3,
                     title='Gender Distribution', color_discrete_sequence=['skyblue', 'lightcoral'])

# Center the title
fig_gender.update_layout(title_x=0.5)
# Adjust the figure size and other layout properties
fig_gender.update_traces(textinfo='percent+label', pull=[0, 0], textposition='inside', hole= 0.4, marker=dict(line=dict(color='white', width=2)))
fig_gender.update_layout(autosize=False, width=500, height=500)

# Create an interactive histogram using Plotly
fig_age = px.histogram(train_df, x='Age', nbins=8,
                       title='Age Distribution',
                       labels={'Age': 'Age', 'count': 'Frequency'},
                       opacity=0.7,  # Adjust the opacity of the bars
                       color_discrete_sequence=['blue'],  # Custom bar color
                       template='plotly_white',  # Use a white background template

                       )

# Center the title
fig_age.update_layout(title_x=0.5)
# Calculate the mean age
mean_age = train_df['Age'].mean()

# Add a vertical line for the mean age
fig_age.add_vline(x=mean_age, line_dash='dash', line_color='red', line_width=2, annotation_text=f'Mean Age ({mean_age:.2f})', annotation_position='top')

# Show the figure
fig_age.update_traces(marker=dict(line=dict(width=2, color='black')))  # Add lines to edges of bars
fig_age.update_layout(autosize=False, width=1000, height=450)  # Adjust the figure size

fig_gender

# Count the number of each gender
gender_counts = train_df['Gender'].value_counts().reset_index()

# Create an interactive bar plot using Plotly with different colors
fig_gender_bar = px.bar(gender_counts, x='index', y='Gender', text='Gender',
             labels={'index': 'Gender', 'Gender': 'Count'},
             title='Distribution of Gender',
             color='index')  # Different colors for each bar

# Center the title
fig_gender_bar.update_layout(title_x=0.45)

# Adjust the figure size and other layout properties
fig_gender_bar.update_traces(textposition='outside')  # Place the text outside the bars
fig_gender_bar.update_layout(xaxis_title='', yaxis_title='Count', xaxis_categoryorder='total ascending',
                  autosize=False, width=500, height=500)

# Show the figure
fig_gender_bar.show()

# Select the top N professions by count
top_n = 10  # Change this value as needed
top_professions = train_df['Profession'].value_counts().nlargest(top_n).index

# Create a DataFrame to store the count of each profession
count_df = train_df[train_df['Profession'].isin(top_professions)]
count_df = count_df['Profession'].value_counts().reset_index()
count_df.columns = ['Profession', 'Count']

# Create a count plot for the top N professions using Plotly Express with different colors
prof_dist = px.bar(count_df,
             x='Profession',
             y='Count',
             title=f'Top {top_n} Professions Count Plot',
             labels={'Profession': 'Profession', 'Count': 'Count'},
             width=800, height=600,
             color='Profession')

# Center the title
prof_dist.update_layout(title_x=0.5)

# Rotate x-axis labels for better readability
prof_dist.update_xaxes(tickangle=45)

# Show the figure
prof_dist.show()

# Create a cross-tabulation of Cluster and Profession
cluster_profession = pd.crosstab(train_df['Cluster'], train_df['Profession'])

# Reset the index of the crosstab for Plotly Express
cluster_profession = cluster_profession.reset_index()

# Melt the DataFrame for easy plotting
cluster_profession_melted = cluster_profession.melt(id_vars='Cluster', var_name='Profession', value_name='Count')

# Create a grouped bar plot
prof_clusters = px.bar(cluster_profession_melted, x='Cluster', y='Count', color='Profession',
                       title='Cluster Distribution by Profession (Grouped Bar Plot)',
                       labels={'Cluster': 'Cluster', 'Count': 'Count', 'Profession': 'Profession'},
                       template='plotly_white', barmode='group',
                       width=500, height=500)

prof_clusters.show()

import plotly.express as px
import seaborn as sns

# Set the style
sns.set(style="whitegrid")

# Create a histogram with overlapping distributions for each cluster
work_exp_clusters = px.histogram(train_df, x='Work_Experience', color='Cluster',
                   title='Work Experience Distribution by Cluster',
                   labels={'Work_Experience': 'Work Experience', 'Cluster': 'Cluster'},
                   template='plotly_white', nbins=15,
                   width=500, height=500,  # Set width and height here
                   barmode='overlay',  # Use 'overlay' for edge lines
                   opacity=0.6)  # Adjust opacity for overlapping bars

# Show the plot
work_exp_clusters.show()

cluster_profession = pd.crosstab(train_df['Cluster'], train_df['Profession'])

# Create a heatmap
trace = go.Heatmap(
    z=cluster_profession.values,
    x=cluster_profession.columns,
    y=cluster_profession.index,
    # colorscale='YlGnBu',
    colorbar=dict(title='Count')
)

# Create annotations
annotations = []
for i, row in enumerate(cluster_profession.values):
    for j, val in enumerate(row):
        annotations.append(
            dict(
                text=str(val),
                x=cluster_profession.columns[j],
                y=cluster_profession.index[i],
                xref='x',
                yref='y',
                font=dict(color='white' if val > cluster_profession.values.max() / 2 else 'black'),
                showarrow=False)
        )

layout = go.Layout(
    title='Cluster-Profession Relationship Heatmap',
    xaxis=dict(title='Profession'),
    yaxis=dict(title='Cluster'),
    annotations=annotations
)

prof_cluster_heatmap = go.Figure(data=[trace], layout=layout)

prof_cluster_heatmap.show()

import plotly.express as px

# Create a crosstab of 'Ever_Married' and 'Graduated'
cross_tab = pd.crosstab(train_df['Ever_Married'], train_df['Graduated'], normalize='index')

# Reset the index for plotting
cross_tab = cross_tab.reset_index()

# Melt the DataFrame for plotting
melted_df = cross_tab.melt(id_vars='Ever_Married', var_name='Graduated', value_name='Proportion')

# Create pie chart for 'Ever_Married'
fig_ever_married = px.pie(melted_df, names='Ever_Married', values='Proportion',
                          title='Proportion of Ever Married',
                          labels={'Ever_Married': 'Ever Married', 'Proportion': 'Proportion'},
                          width=400, height=400)

# Create pie chart for 'Graduated'
fig_graduated = px.pie(melted_df, names='Graduated', values='Proportion',
                       title='Proportion of Graduated',
                       labels={'Graduated': 'Graduated', 'Proportion': 'Proportion'},
                       width=400, height=400)

# Show the pie charts
fig_ever_married.show()
fig_graduated.show()

# Calculate counts for each combination of 'Family_Size' and 'Spending_Score'
counts_df = train_df.groupby(['Family_Size', 'Spending_Score']).size().reset_index(name='Count')

# Create a line chart using Plotly Express with different lines for each 'Spending_Score' category
spending_famSize_line = px.line(counts_df, x='Family_Size', y='Count', color='Spending_Score',
             title='Distribution of Spending Score by Family Size',
             labels={'Family_Size': 'Family Size', 'Count': 'Count', 'Spending_Score': 'Spending Score'},
              width=1025, height=450)

# Center the title
spending_famSize_line.update_layout(title_x=0.5)

# Show the figure
spending_famSize_line.show()

# Create a violin plot using Plotly Express
prof_family_Violin = px.violin(train_df, x='Profession', y='Family_Size', color='Profession',
                title='Violin Plot of Profession vs. Family Size',
                labels={'Profession': 'Profession', 'Family_Size': 'Family Size'},
                width=1025, height=500)

# Center the title
prof_family_Violin.update_layout(title_x=0.5)

# Rotate x-axis labels for better readability
prof_family_Violin.update_xaxes(tickangle=45)

# Show the figure
prof_family_Violin.show()

# Define a custom color map for each cluster
cluster_color_map = {
    0: 'rgb(255, 87, 34)',  # Red
    1: 'rgb(33, 150, 243)',  # Blue
    2: 'rgb(76, 175, 80)',  # Green
}

# Create an interactive histogram facet grid for each cluster
cluster_age_dist = px.histogram(
    train_df,
    x='Age',
    color='Cluster',
    nbins=20,
    facet_col='Cluster',
    title='Age Distribution per Cluster',
    labels={'Age': 'Count'},
    marginal='box',
    opacity=0.7,
    color_discrete_map=cluster_color_map  # Apply the custom color map
)

# Customize the layout
cluster_age_dist.update_xaxes(title_text='Age')
cluster_age_dist.update_layout(showlegend=False)

# Show the interactive plot
cluster_age_dist.show()

# Create subplots with 2 rows and 2 columns
fam_in_cluster = make_subplots(rows=2, cols=2, subplot_titles=["Cluster 0", "Cluster 1", "Cluster 2", "Cluster 3"])

# Define the unique Family Size values
family_size_values = train_df['Family_Size'].unique()
family_size_values.sort()

# Generate a color mapping based on unique Family Size values
colors = {family_size: f'hsl({i * (360 // len(family_size_values))}, 50%, 50%)' for i, family_size in enumerate(family_size_values)}

# Initialize a list to store traces for the legend
legend_trace = []

# Iterate through clusters
for i in [0, 1, 2, 3]:
    row = (i // 2) + 1
    col = (i % 2) + 1

    # Filter the dataframe for the current cluster
    cluster_df = train_df[train_df['Cluster'] == i]

    # Initialize lists to store x, y, and color data
    x_data = []
    y_data = []
    color_data = []

    # Iterate through Family Size values
    for family_size in family_size_values:
        # Filter data for the current family size
        family_size_data = cluster_df[cluster_df['Family_Size'] == family_size]

        # Calculate the count for the current family size
        count = len(family_size_data)

        # Append data to the lists
        x_data.append(family_size)
        y_data.append(count)
        color_data.append(colors[family_size])

    # Create a bar trace for the current cluster
    trace = go.Bar(
        x=x_data,
        y=y_data,
        name=f"Cluster {i}",
        showlegend=False,  # Remove the cluster legend
        marker_color=color_data
    )

    # Add the trace to the subplots
    fam_in_cluster.add_trace(trace, row=row, col=col)

# Create a dummy trace for the Family Size legend
for family_size, color in colors.items():
    legend_trace.append(go.Bar(
        x=[],
        y=[],
        name=f"Family Size {family_size}",
        marker_color=color
    ))

# Update layout settings
fam_in_cluster.update_layout(
    title_text="Family Size Distribution by Cluster",
    xaxis=dict(title="Family Size"),
    yaxis=dict(title="Count"),
    showlegend=True
)

# Add a common legend for Family Size
fam_in_cluster.add_trace(legend_trace[0])

# Show the plot
fam_in_cluster.show()

# Calculate counts for each combination of 'Gender' and 'Spending_Score'
counts_df = train_df.groupby(['Gender', 'Spending_Score']).size().reset_index(name='Count')

# Create a grouped bar plot using Plotly Express with different colors for each 'Spending_Score' category
gender_score_bar = px.bar(counts_df, x='Gender', y='Count', color='Spending_Score',
             title='Gender vs. Spending Score',
             labels={'Gender': 'Gender', 'Count': 'Count', 'Spending_Score': 'Spending Score'},
             width=500, height=500, barmode='group',
             template='plotly_dark')

# Center the title
gender_score_bar.update_layout(title_x=0.5)

# Show the figure
gender_score_bar.show()

# Create an interactive violin plot using Plotly with different colors for each violin side by side
age_score_violin = px.violin(train_df, x='Spending_Score', y='Age',
                title='Age vs. Spending Score (Violin Plot)',
                labels={'Spending_Score': 'Spending Score (Numerical)', 'Age': 'Age'},
                category_orders={'Spending_Score': train_df['Spending_Score'].unique()},  # Preserve the order
                width=500, height=500,
                color='Spending_Score')  # Use 'Spending_Score' for coloring

# Center the title
age_score_violin.update_layout(title_x=0.5)

# Show the figure
age_score_violin.show()

import plotly.express as px
import pandas as pd

age_counts = train_df.groupby(['Cluster', 'Age']).size().reset_index(name='Count')

age_scatter = px.scatter(
    age_counts,
    x='Age',
    y='Count',
    color='Cluster',
    size='Count',
    title='Scatter Plot of Age vs. Count Colored by Cluster',
    labels={'Age': 'Age', 'Count': 'Count', 'Cluster': 'Cluster'},
    color_discrete_sequence=px.colors.sequential.Viridis  # Adjust colors here
)

age_scatter.update_layout(
    xaxis_title='Age',
    yaxis_title='Count',
)

age_scatter.show()

"""Function for customer analysis page"""

def customers_page():
    page = html.Div([
            html.H1('Customer Segmentation Dashboard', className='text-center p-3'),
            html.H5('A product of the NRB (National Resources & Business) Tech ', className='text-center p-3'),
            html.H6('#NB# Refresh each page after opening it', className='text-center p-3'),
            html.Hr(),
            html.H2('Get to study our Customer Base', className='text-center p-3'),

                dbc.Row([
                    dcc.Graph(figure=fig_age, config={'displayModeBar': False}),
                ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='customer-distribution'),

            dbc.Row([
                dbc.Col(
                    dcc.Graph(figure=gender_score_bar, config={'displayModeBar': False}),
                    width=6
                ),
                dbc.Col(
                    dcc.Graph(figure=age_score_violin, config={'displayModeBar': False}),
                    width=6
                )
            ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='customer-distribution'),

            dbc.Row([
                dbc.Col(
                    dcc.Graph(figure=spending_famSize_line, config={'displayModeBar': False}),
                    width=12
                )
            ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}),

            dbc.Row([
                dcc.Graph(figure=prof_family_Violin, config={'displayModeBar': False}),
                #width=12
            ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}),
        ])
    return page

data1 = data

# Count the occurrences of each profession
profession_counts = data1['Profession'].value_counts()

# Select the top 4 professions and consolidate the rest as 'Other'
top_professions = profession_counts.head(4).index
data1['Profession'] = data1['Profession'].apply(lambda x: x if x in top_professions else 'Other')

# Select attributes for the sunburst chart
data_subset = data1[['Profession', 'Graduated', 'Cluster']]

# Create the Sunburst Chart with custom style and colors
big_sunburst = px.sunburst(data_subset,
                  path=['Cluster', 'Graduated', 'Profession'],
                  title='Sunburst Chart for Cluster, Graduated, and Top Professions',
                  color='Cluster',
                  color_continuous_scale='Blues',
                  branchvalues='total',  # Choose 'total' for the sum of each sector to be 100%
                  template='plotly_dark')  # Use a dark template for a visually appealing look

#myColors = ["#fef7df"," #BEBADA"," #fef7df"," pink"," #FCCDE5"," #E5C494"," #E82127"," #fef7df"," #fef7df"," #fef7df"," #FFFFB3"," #CCEBC5"," #FFED6F"," #FDB462"," #fef7df"," #BC80BD"," #fef7df"," #1fa230"," #2f4b7c"," #17cc39"," #006766"," #207a27"," #faa2d4"," #ffbc6c"," #737584"," #1e3152"," #a05195"," #ffd6ae"," #ffeb09"," #c3b404"," #1f5bcc"," #d45087"," #cca680"," #daff6c"," #6acff7"," #ff8500"," #f95d6a"," #f2ae9c"," #cc0000"," #eeeeee"," #e700a2"," #4dcac8"," #5c1fcc"," #ff7c43"," #6d4f2d"]

# Update layout for better aesthetics
big_sunburst.update_layout(
    margin=dict(l=0, r=0, b=0, t=40),
    sunburstcolorway=["#fef7df", "#EF553B", "#00cc96", "#ab63fa", "#FFA15A"]
)

big_sunburst.show()

"""##### CUSTOMER Analysis
- Visuals come here:
"""

# Create visuals for Company Customer Analysis
def create_visuals():
    # Example visuals (you can replace these with your own analysis and plots)
    bar_chart = dcc.Graph(
        id='bar-chart',
        figure=px.bar(data, x='Profession', title='Profession Distribution'),
    )

    scatter_plot = dcc.Graph(
        id='scatter-plot',
        figure=px.scatter(data, x='Age', y='Spending_Score', color='Segmentation', title='Age vs Spending Score'),
    )

    return html.Div([bar_chart, scatter_plot])

"""### DASHBOARD PAGES

#### HOMEPAGE
"""

# Create the histogram for work experience by cluster
work_experience_by_cluster = dcc.Graph(figure=work_exp_clusters, config={'displayModeBar': False})

# Modify the homepage layout to include the new chart
homepage = html.Div([
    html.H2('Cluster Customer Distribution', className='text-center p-3'),

    # Customer Distribution div
    html.Div([
        dbc.Row([
            dbc.Col(
                dcc.Graph(figure=fig_gender, config={'displayModeBar': False}),
                width=6
            ),
            dbc.Col(
                dcc.Graph(figure=fig_gender_bar, config={'displayModeBar': False}),
                width=6
            )
        ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='customer-distribution'),

        html.Div([
            dbc.Row([
                dcc.Graph(figure=age_scatter, config={'displayModeBar': False}),
            ]),
        ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='customer-distribution'),
    ]),

    # Charts for Work Experience and Cluster Distribution by Profession
    html.Div([
        dbc.Row([
            dbc.Col(
                dcc.Graph(figure=work_exp_clusters, config={'displayModeBar': False}),
                width=6
            ),
            dbc.Col(
                dcc.Graph(figure=prof_clusters, config={'displayModeBar': False}),
                width=6
            ),
        ]),
    ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='customer-distribution'),

    html.Div([
            dbc.Row([
                dcc.Graph(figure=fam_in_cluster, config={'displayModeBar': False}),
            ]),
            dbc.Row([
                dcc.Graph(figure=cluster_age_dist, config={'displayModeBar': False}),
            ]),
        ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='customer-distribution'),

    # Profession and Cluster heatmap
    html.Div([
        dbc.Row([
            dcc.Graph(figure = prof_cluster_heatmap, config={'displayModeBar': False}),
        ]),
    ], className = 'p-3 mb-2 bg-light text-dark', style = {'border': '1px solid #ccc'}, id='sunburst-charts'),

    # Sunburst charts
    html.Div([
        dbc.Row([
            dbc.Col(
                dcc.Graph(figure=sunburst1, config={'displayModeBar': False}),
                width=6
            ),
            dbc.Col(
                dcc.Graph(figure=sunburst2, config={'displayModeBar': False}),
                width=6
            ),
        ]),
    ], className='p-3 mb-2 bg-light text-dark', style={'border': '1px solid #ccc'}, id='sunburst-charts'),

])

"""#### TABLE VIEW PAGE"""

# Dropdown for search by
search_by_dropdown = dcc.Dropdown(
    id='search-by-dropdown',
    options=[
        {'label': col, 'value': col} for col in data.columns
    ],
    value=data.columns[0],  # Default value
)

# Textbox for search
search_textbox = dcc.Input(
    id='search-textbox',
    type='text',
    debounce=True,
    placeholder='Search...',
)

# Table View Page
tablepage = html.Div([
    dbc.Row(dbc.Col(html.H2('FULL TABLE VIEW', className='text-center mb-3 p-3'))),
    dbc.Row([
        dbc.Col([
            html.H5('Search By:', className='text-left'),
            search_by_dropdown,
            html.Hr(),
            html.H5('Search Term:', className='text-left'),
            search_textbox,
            html.Hr(),
            dash_table.DataTable(
                id='tableview-table',
                columns=[{"name": i, "id": i} for i in data.columns],
                data=data.to_dict('records'),
                page_size=15,  # Number of rows per page
                sort_action='native',  # Enables data sorting
                style_table={'height': '400px', 'overflowY': 'auto', 'border': '2px solid #444'},  # Bold borders and custom table color
                style_cell={'backgroundColor': '#f9f9f9', 'color': '#000'},  # Change cell color and text color
            ),
        ],
        width={'size': 12, 'offset': 0, 'order': 1}),
    ]),
])

"""#### SUNBURST PAGE"""

sunburstpage = [
    dbc.Row(dbc.Col(html.H2('SUNBURST VIEW', className='text-center mb-3 p-3'))),
    dbc.Row([
        dbc.Col([
            html.H5('Cluster Sunburst', className='text-left'),
            dcc.Graph(id='chrt-cluster-sunburst', figure=big_sunburst, style={'height': 800}),
            html.Hr(),
        ],
            width={'size': 12, 'offset': 0, 'order': 1}),
    ]),
]

"""#### About Us Page"""

about_us_page = html.Div([
    dbc.Row(dbc.Col(html.H1('ABOUT US', className='text-center mb-3 p-3'))),
    dbc.Row([
        dbc.Col(html.H4('Click a name below to meet us on LinkedIn', className='text-center mb-3 p-3')),
            ]),
    dbc.Row([
        dbc.Col([
            html.Div([
                html.Img(src='https://github.com/Tinago-N/Dataset-Location/blob/main/Ngoni.jpg?raw=true', style={'width': '100%', 'height': 'auto', 'borderRadius': '15px'}),
                html.A(html.H4('Ngonidzashe Tinago', className='text-center mb-3 p-3'), href='https://www.linkedin.com/in/ngonidzashe-tinago-3b0782233?utm_source=share&utm_campaign=share_via&utm_content=profile&utm_medium=android_app', target='_blank'),
                html.P('Email: tinagongoni@gmail.com', className='text-center p-3'),
            ], className='image-container'),
        ],
            width={'size': 4, 'offset': 0, 'order': 1}),
        dbc.Col([
            html.Div([
                html.Img(src='https://github.com/Tinago-N/Dataset-Location/blob/main/Rejoice.jpg?raw=true', style={'width': '100%', 'height': 'auto', 'borderRadius': '15px'}),
                html.A(html.H4('Rejoice Chitengu', className='text-center mb-3 p-3'), href='https://www.linkedin.com/in/rejoice-chitengu', target='_blank'),
                html.P('Email: reojicechitengu06@gmail.com', className='text-center p-3'),
            ], className='image-container'),
        ],
            width={'size': 4, 'offset': 0, 'order': 2}),
        dbc.Col([
            html.Div([
                html.Img(src='https://github.com/Tinago-N/Dataset-Location/blob/main/Brandon.jpg?raw=true', style={'width': '100%', 'height': 'auto', 'borderRadius': '15px'}),
                html.A(html.H4('Emmanuel Brandon Ramphabana', className='text-center mb-3 p-3'), href='https://www.linkedin.com/in/emmanuel-ramphabana-83321b15a/', target='_blank'),
                html.P('Email: RamphabanaEmmanuel@gmail.com', className='text-center p-3'),
            ], className='image-container'),
        ],
            width={'size': 4, 'offset': 0, 'order': 3}),
    ]),
    dbc.Row([
        dbc.Col([
            html.P('Three visionary final-year Data Science students who harnessed the formidable might of K-Means clustering and elevated it to unparalleled heights with the cutting-edge magic of APSO. Our capstone project is nothing short of a revolution in the world of customer segmentation, promising to leave you utterly spellbound.', className='text-center p-3'),
        ],
            width={'size': 12, 'offset': 0, 'order': 1}),
    ]),
    dbc.Row([
        dbc.Col([
            html.H2('Contact Us', className='text-center mb-3 p-3'),
            html.P('Company Name: NRB (National Resources & Business)', className='text-center p-3'),
            html.P('456 Imaginary Avenue, Pretend City, South Africa', className='text-center p-3'),
            html.P('Phone: +27 (0) 123 456 789', className='text-center p-3'),
            html.P('Email: info@nbrfakesa.com', className='text-center p-3'),
        ],
            width={'size': 12, 'offset': 0, 'order': 1}),
    ]),
], className='about-us-container')

"""#### Customer Analysis Page"""

# Customer Distribution div
company_analysis_page = customers_page()

def display_company_customer_analysis(pathname):
    if pathname == '/company-customer-analysis':
        return company_analysis_page
    elif path == '/About-Us':
        return about_us_page
    else:
        return content  # or whatever the default content is

"""#### DASH APP"""

from jupyter_dash import JupyterDash  # Import JupyterDash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
from dash import dash_table
import dash_table

# Define CONTENT_STYLE
CONTENT_STYLE = {
    'margin-left': '15rem',
    'margin-right': '2rem',
    'padding': '2rem 1rem',
}

# Define the app
app = JupyterDash(__name__, external_stylesheets=[dbc.themes.SLATE], suppress_callback_exceptions=True)

server = app.server

# Define the app layout
app.layout = html.Div([
    dcc.Location(id='url'),
    sidebar,
    content
])

# Add CSS styles on about us page
app.css.append_css({
    'external_url': 'https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css'
})

# Update table based on search criteria
@app.callback(
    Output('tableview-table', 'data'),
    Input('search-textbox', 'value'),
    Input('search-by-dropdown', 'value')
)
def update_table(search_value, search_column):
    if search_value and search_column:
        filtered_data = data[data[search_column].str.contains(search_value, case=False)]
        return filtered_data.to_dict('records')
    else:
        return data.to_dict('records')

@app.callback(
    Output("page-content", "children"),
    [Input("url", "pathname")]
)
def render_page_content(pathname):
    print("Current pathname:", pathname)
    if pathname == "/":
        return company_analysis_page
    elif pathname == "/churn":
        return homepage
    if pathname == "/tableview":
        return tablepage
    elif pathname == "/sunburst":
        return sunburstpage
    elif pathname == '/about-us':
        return about_us_page
    else:
        return html.P("Page not found")  # An else clause to handle unknown URLs

if __name__ == "__main__":
    app.run_server(debug=True, port=8009)
    #app._terminate_server_for_port("localhost", 8100)
